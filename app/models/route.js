'use strict';

/**
 * Module dependencies.
 */

const mongoose = require('mongoose');
const Schema = mongoose.Schema;
const getTags = tags => tags.join(',');
const setTags = tags => tags.split(',');
const ObjectId = require('mongoose').Types.ObjectId;

/**
 * Route Schema
 */

const RouteSchema = new Schema({
    stravaId: {type: String, default: '', index: true, unique: true, sparse: true},           // The ID this route has in Strava
    title: {type: String, default: '', trim: true},                         // Title of the route
    location: {type: String, default: '', trim: true},                      // General location (e.g. "Saarbruecken")
    body: {type: String, default: '', trim: true},                          // Optional description
    user: {type: Schema.ObjectId, ref: 'User', default: null},              // The user who created this route
    geo: [{type: Schema.ObjectId, ref: 'Geo'}],         // List of references to geo points
    parts: [{type: Schema.ObjectId, ref: 'Route'}],     // List of routes that are part of this route (only for generated routes)
    distance: {type: Number , default: 0, trim: true},      // Distance in meters
    comments: [{                                            // Comments, currently not used
        body: {type: String, default: ''},
        user: {type: Schema.ObjectId, ref: 'User'},
        createdAt: {type: Date, default: Date.now}
    }],
    tags: {type: [], get: getTags, set: setTags},           // Tags (e.g. riding, trail)
    createdAt: {type: Date, default: Date.now},             // The creation date (i.e. when imported into ExploX)
    isRoute: {type: Boolean, default: true},                // True iff this is a route, otherwise it is a segment
    isGenerated: {type: Boolean, default: false},           // True iff this is a route and it has been generated by the ExploX algorithm
    queryDistance: {type: Number , default: 0, trim: true},      // Distance in meters of the user query (only for generated routes)
});

/**
 * Validations
 */

RouteSchema.path('title').required(true, 'Route title cannot be blank');

/**
 * Methods
 */

RouteSchema.methods = {

    /**
     * Save article and upload image
     * @api private
     */

    uploadAndSave: function () {
        const err = this.validateSync();
        if (err && err.toString()) throw new Error(err.toString());
        return this.save();
    },

    /**
     * Add comment
     *
     * @param {User} user
     * @param {Object} comment
     * @api private
     */

    addComment: function (user, comment) {
        this.comments.push({
            body: comment.body,
            user: user._id
        });
        return this.save();
    },

    /**
     * Remove comment
     *
     * @param {String} commentId
     * @api private
     */

    removeComment: function (commentId) {
        const index = this.comments
            .map(comment => comment.id)
            .indexOf(commentId);

        if (~index) this.comments.splice(index, 1);
        else throw new Error('Comment not found');
        return this.save();
    }
};

/**
 * Statics
 */

RouteSchema.statics = {

    delete: function (_id) {
        return this.find({_id: ObjectId(_id)}).remove().exec();
    },

    /**
     * Find route by id
     *
     * @param {ObjectId} _id
     * @api private
     */

    load: function (_id) {
        return this.load_options({criteria: {_id: ObjectId(_id)}});
    },

    /**
     * Load
     *
     * @param {Object} options
     * @api private
     */

    load_options: function (options) {
        options.select = options.select || '';
        return this.findOne(options.criteria)
            .populate('user', 'name email username')
            .populate('geo')
            .populate('parts')
            .populate('comments.user')
            .select(options.select)
            .exec();
    },

    /**
     * List routes
     *
     * @param {Object} options
     * @api private
     */

    list: function (options) {
        let criteria = options.criteria || {};
        if (criteria._id) {
            criteria._id = ObjectId(criteria._id);
        }
        if (!options.detailed) {
            return this.find(criteria)
                .sort({createdAt: -1})
                .exec();
        }
        return this.find(criteria)
            .populate('user', 'name username')
            .populate('geo', 'name location')
            .sort({createdAt: -1})
            .exec();
    },

    update_route: function (id, data) {
        return this.update({_id: ObjectId(id)}, data, function (err) {
        }).exec();
    },
};

mongoose.model('Route', RouteSchema);
